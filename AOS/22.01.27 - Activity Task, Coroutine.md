## 태스크 관리

태스크 관리란 액티비티를 어떻게 생성하고 관리하는지를 제어하는 일을 의미한다. 시스템에는 액티비티의 태스크를 유지하는 기본 규칙이 있으며 일반적으로는 이 기본 규칙을 그대로 이용한다. 하지만 특정 상황에서 태스크를 관리해야 할 필요가 있다.

### 액티비티 태스크

액티비티 태스크란 앱이 실행될 때 시스템에서 액티비티의 각종 정보를 저장하는 공간이다. 가령 두 개의 액티비티로 된 앱에서 `Activity_A` 에서 `Activity_B` 로 `Intent` 되었을 때 현재 액티비티 객체는 2개 존재하고 시스템은 액티비티가 실행되었다는 정보를 저장하려고 태스크를 만든다. 이때 액티비티 태스크에 액티비티 객체의 대한 정보가 `Queue` 의 형태로 쌓인다. `A -> B` 이므로 A, B 로 쌓여있고 뒤로 가기 버튼을 누르면 `B` 가 종료되고 `A` 가 화면에 출력된다.

### 앱끼리 액티비티 태스크 공유

앱과 앱을 공유하는 경우 태스크는 어떻게 될까? 서로 다른 앱이므로 태스크가 2개가 생길 것 같지만 사실은 1개의 태스크를 공유하고 있다. 쉽게 말해 태스크는 사용자적 관점에서의 프로그램의 논리적인 실행 단위이다. 그렇다면 만약 `앱 A`에서 `앱 B` 의 액티비티를 실행하고 앱 B에서 액티비티를 실행하면 어떻게 될까? 위에서 말했던 것처럼 프로그램의 논리적인 실행 단위이므로 앱이 2개가 실행된 상태, 즉 2개의 `액티비티 태스크` 가 생성되었다고 생각하면 된다. 한 번의 인탠트에 한 번의 액티비티 객체가 생성되므로 별도의 객체이다.

## 태스크 제어

태스크를 관리하는 방법을 이해했다면 이제 제어하는 방법에 대해 알아보도록 하자. `태스크 제어` 는 2가지 방법이 있다.

- 액티비티가 등록된 매니페스트에 `<activity>` 태그의 `launchMode` 를 이용한다.

```xml
<activity android:name=".TwoActivity" android:launchMode="singleTop">
```

- 인탠트의 `flags` 정보를 설정하여 제어한다.

```kotlin
val intent = Intent(this, TwoActivity::class.java)
intent.flags = Intent.FlAG_ACTIVITY_SINGLE_TOP
StartActivity(intent)
```

두 방법의 차이는 `매니페스트` 에 등록하면 액티비티가 실행될 때마다 적용되고 인탠트에 설정하는 경우에는 인탠트가 발생할 때만 한 번만 적용된다.

### LaunchMode 속성 값

`launchMode` 에는 다양한 속성 값이 존재한다.

- 스탠다드 : 자신의 액티비티에서 자신의 액티비티가 생성되어도 그대로 위에 얹는다.
- 싱글 톱 : 자신의 액티비티에서 자신의 액티비티가 생성되면 객체를 생성하지 않는다. 그 대신 `onNewIntent` 함수가 호출된다.

```kotlin
override fun onNewIntent(intent: Intent?) {
	super.onNewIntent(intent)
}
```

이 함수를 재정의 해놓으면 `싱글 톱` 으로 설정한 액티비티가 위에 있는 상태에서 다시 액티비티를 생성한 경우 자동으로 호출된다. 그렇다면 위의 속성을 어떤 상황에서 사용할 수 있을까? 해당 속성을 카카오톡에서 사용하고 있는 것을 알 수 있다. 이미 채팅방에 들어와 있을 때 다른 채팅방에서 카톡이 와서 알림이 뜬 경우 우리는 해당 알림을 클릭하여 새로운 채팅방을 들어갈 수 있다. 이때 채팅방에 대한 액티비티를 새로 생성해야 할까? `스탠다드` 로 설정한 경우엔 액티비티가 계속해서 생성될 것이다. 하지만 `싱글 톱` 으로 생성한 경우 해당 채팅방에서 보여주고 있는 채팅방 변경하면 된다. 

- 싱글 태스크 : 자신의 앱에서 다른 앱의 액티비티를 실행했을 때 하나의 태스크에 올리는 것이 아니라 다른 태스크를 생성하여 별도로 관리하도록 한다.
- 싱글 인스턴스 : 설정한 액티비티만 별도의 태스크로 관리한다. 결과적으로 별도의 태스크에는 설정한 액티비티 객체만 존재한다.

## 액티비티 ANR 문제와 코루틴

`ANR` 은 `Answer Not Response` 로 액티비티가 응답하지 않는 오류 상황을 의미한다. 액티비티를 작성할 때 이를 고려하지 않으면 앱이 수시로 종료될 가능성이 있다. 액티비티는 사용자 이벤트에 5초 이내에 반응을 해야한다. 반응하지 않는 경우 `ANR` 이 발생한다. 

### 메인 스레드

시스템에서 액티비티를 실행하는 수행 흐름을 `메인 쓰레드` 또는 `UI 쓰레드` 라고 한다. 사실 메인 쓰레드가 오래 걸리는 작업을 수행한다고 해서 무조건 오류가 발생하지는 않는다. 오래 걸려도 사용자가 화면을 터치하지 않거나 다른 이벤트가 발생하지 않는 경우엔 괜찮다. 하지만 사용자가 언제 화면을 터치할지 모르므로 `ANR` 을 고려해야 한다. 

### 별도의 스레드 사용

이 문제를 해결하기 위해선 개발자가 `별도의 스레드` 를 생성해서 이곳에서 오래 걸리는 작업을 진행하도록 하면 된다. 하지만 이런 경우 `ANR` 은 해결되지만 별도의 스레드에서의 작업을 통해 화면을 출력할 수는 없다. 왜냐하면 화면 출력은 메인 스레드에서 작동하기 때문이다. 

### 코루틴 사용

코루틴은 `ANR` 을 해결하기 위한 방법으로 `비동기 경량 스레드` 이다. 코루틴은 안드로이드 시스템에서 제공하는 것이 아닌 프로그래밍 언어인 코틀린에서 제공하는 기능이다. 코루틴은 수행 흐름을 여러 갈래로 만들어 함께 처리한다. 즉, `비동기 처리 방식` 과 동일하다. 비동기 처리 방식이면 일반적으로 스레드를 생각하는데 스레드는 성능에 문제가 많고 자유로운 처리가 복잡한데 이를 해결한 것이 `코루틴`

- 경량
- 메모리 누수가 적음
- 다양한 기능 제공
- 많은 제트팩 라이브러리에 적용되어 있음

`코루틴` 을 사용하기 위해선 먼저 `스코프` 를 작성해야 한다. 스코프에서 코루틴을 구동한다. 스코프는 성격이 같은 코루틴을 말한다. 한 스코프에 여러 코루틴을 구동할 수 있고 한 어플리케이션에서는 여러 스코프를 작성할 수 있다. 결과적으로 스코프는 성격이 같은 여러 코루틴이 동작하기 위한 공간을 의미한다.

```kotlin
val channel = Channel<Int>()
val backgroundScope = CoroutineScope(Dispatchers.Default + Job())
backgroundScope.launch {
	var sum = 0L
	var time = measureTimeMillis {
		for (i in 1..2_000_000_000) {
			sum += i
		}
	}
Log.d("kkang", "time : $time")
channel.send(sum.toInt())
}

val mainScope = GolbalScope.launch(Dispatchers.Main) {
	channel.consumeEach {
		binding.resultView.text = "sum : $it"
	}
}
```

코투린 스코프는 위 코드처럼 `CoroutineScope` 객체를 직접 구현할 수 있고 `GlobalScope` `ActorScope` `ProducerScope` 등의 코틀린 언어가 제공하는 스코프를 이용할 수도 있다. 현재 코드는 백그라운드에서 1 부터 20억까지를 더 하는 계산을 코루틴으로 실행하고 이를 채널에 담는다. 채널에 담기면 `consumeEach` 를 통해 데이터를 출력한다.

### 디스패쳐

`디스패쳐` 는 스코프에서 구동한 코루틴이 어디서 동작해야하는지를 나타낸다. 

- Dispatcher.Main : 액티비티의 매인 스레드에서 동작하는 코루틴
- [Dispatcher.IO](http://Dispatcher.IO) : 파일에 읽거나 쓰기 또는 네트워크 작업에 최적화
- Dispatcher.Default : CPU를 많이 사용하는 작업을 백그라운드에서 실행
